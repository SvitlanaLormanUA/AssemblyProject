.model small
.stack 100h

.data
    buffer db 80h dup(?)    ; Буфер для зберігання введених даних
    sumVal dw ?             ; Змінна для суми значень
    countVal dw ?           ; Змінна для підрахунку кількості значень
    averageMsg db ' Average value: $'
    keyBuffer db 80h dup(?) ; Буфер для зберігання ключів
    valueBuffer dw 80h dup(?) ; Буфер для зберігання значень
    sortedKeyBuffer db 80h dup(?) ; Буфер для зберігання відсортованих ключів

.code
main proc
    mov ax, @data
    mov ds, ax

    mov ah, 3Fh             ; Функція DOS для відкриття файлу (стандартний ввід)
    mov bx, 0               ; Вказівник файлу (0 = стандартний ввід)
    lea dx, buffer          ; Вказівник на буфер
    mov cx, 80h             ; Кількість байт для читання
    int 21h                 ; DOS переривання

    cmp ax, cx
    jae checking_eof        ; Якщо досягнуто кінець файлу, перевірте EOF
    mov cx, ax              ; Оновіть лічильник прочитаних символів

output:
    mov ah, 02h             ; DOS-функція для виводу символу
    mov si, 0               ; Ініціалізуємо індекс джерела на 0

print_loop:
    mov dl, [si]            ; Завантажити символ для виводу
    int 21h                 ; Вивести символ
    inc si                  ; Перейти до наступного символу
    loop print_loop         ; Повторюємо, поки CX != 0

checking_eof:
    ; Перевірка кінця файлу
    mov ah, 3Eh             ; DOS-функція для перевірки EOF
    mov bx, 0               ; Вказівник файлу (0 = стандартний ввід)
    int 21h                 ; DOS переривання

    ; Якщо EOF не рівний 128 (0x80), файл закінчено
    cmp ax, 80h
    jne calculate_average   ; Якщо EOF, розрахуйте середнє значення
    jmp exit_program

parse_buffer:
    mov al, [si]            ; Завантажити перший символ ключа
    cmp al, ' '             ; Перевірити, чи символ є пропуском
    je store_value          ; Якщо пробіл, перейти до зберігання значення

    mov [di], al            ; Зберегти символ у буфер ключів
    inc di                  ; Перейти до наступного положення у буфері ключів

store_value:
    inc si                  ; Пропустити пробіл
    mov ax, 0               ; Очистити AX
    mov cx, 0               ; Очистити CX

convert_value:
    lodsb                   ; Завантажити наступний символ
    cmp al, 13              ; Перевірити, чи символ є кінцем рядка
    je end_conversion       ; Якщо так, закінчити конвертацію

    sub al, '0'             ; Конвертувати ASCII у бінарний
    mov ah, 0               ; Очистити AH
    mov bx, 10              ; Множник для конвертації
    mul bx                  ; AX = AL * 10
    add ax, cx              ; Додати до поточного результату
    mov cx, ax              ; Зберегти результат
    jmp convert_value       ; Повторити, поки не буде кінець рядка

end_conversion:
    ; Зберегти значення у буфері значень
    mov [di], cx            ; Зберегти значення
    add di, 2               ; Перейти до наступного положення у буфері значень

    ; Оновити змінні для обчислення середнього значення
    add sumVal, cx          ; Додати до суми
    inc countVal            ; Збільшити лічильник значень

    ; Перевірка кінця рядка
    cmp al, 13              ; Перевірити, чи символ є кінцем рядка
    jne parse_buffer        ; Повернутися до парсингу буфера

calculate_average:
    ; Обчислення середнього значення
    mov ax, sumVal
    cwd                      ; Розширити AX у DX:AX
    idiv countVal            ; Поділити DX:AX на countVal, частка у AX

    ; Виведення середнього значення
    mov dx, offset averageMsg ; Завантажити адресу рядка середнього значення
    mov ah, 09h              ; DOS-функція для друку рядка
    int 21h                  ; DOS переривання

    ; Конвертувати AX у ASCII та вивести
    add dl, '0'              ; Конвертувати у ASCII
    mov ah, 02h              ; DOS-функція для виводу символу
    int 21h                  ; DOS переривання

    jmp sort_keys            ; Перейти до сортування ключів

sort_keys:
    ; Сортування ключів (пузирчасте сортування)
    mov si, offset keyBuffer ; Встановити SI на початок буфера ключів
    mov di, offset valueBuffer ; Встановити DI на початок буфера значень
    mov cx, countVal         ; Ініціалізувати CX кількістю значень

outer_loop:
    mov dx, [di]             ; Завантажити значення
    mov bx, [di + 2]         ; Завантажити наступне значення
    cmp dx, bx               ; Порівняти значення
    jbe no_swap              ; Якщо необхідно, перейти до обміну символами

    ; Обмін ключами
    mov ax, [si]             ; Завантажити перший ключ
    mov cx, [si + 16]        ; Завантажити наступний ключ
    mov [si], cx             ; Перемістити наступний ключ на поточне положення
    mov [si + 16], ax        ; Перемістити поточний ключ на наступне положення

    ; Обмін значеннями
    mov ax, dx               ; Завантажити перше значення
    mov cx, bx               ; Завантажити наступне значення
    mov [di], cx             ; Перемістити наступне значення на поточне положення
    mov [di + 2], ax         ; Перемістити поточне значення на наступне положення

sorting_keys:
    ; Сортування ключів 
    mov si, offset keyBuffer ; Встановити SI на початок буфера ключів
    mov cx, countVal         ; Ініціалізувати CX кількістю значень


inner_loop:
    mov al, [di]             ; Завантажити перший символ
    mov dl, [di + 1]         ; Завантажити наступний символ
    cmp al, dl               ; Порівняти символи
    jbe no_swap              ; Якщо необхідно, перейти до обміну символами

    ; Обмін символами за допомогою тимчасового регістра
    mov bl, al               ; Зберегти поточний символ в BL
    mov al, dl               ; Перемістити наступний символ на поточне положення
     mov ah, 02h             ; DOS-функція для виводу символу
    int 21h                 ; DOS переривання


no_swap:
    add di, 4                ; Перейти до наступного значення
    add si, 2                ; Перейти до наступного ключа
    loop outer_loop          ; Повторити, поки CX != 0

    ; Копіювання відсортованих ключів у буфер
    mov si, offset keyBuffer
    mov di, offset sortedKeyBuffer
    mov cx, countVal
    rep movsw

    ; Виведення відсортованих ключів та значень
    mov si, offset sortedKeyBuffer
    mov cx, countVal
print_sorted_keys:
    ; Виведення ключа
    mov dx, si              ; Завантаження адреси ключа
    mov ah, 09h             ; DOS-функція для виводу рядка
    int 21h                 ; DOS переривання

    ; Виведення роздільника
    mov dl, ','             ; Роздільник
    mov ah, 02h             ; DOS-функція для виводу символу
    int 21h                 ; DOS переривання

    ; Виведення значення
    mov ax, [di]            ; Завантаження значення
    call print_word         ; Вивід значення

    add si, 2               ; Перехід до наступного ключа
    add di, 2               ; Перехід до наступного значення
    loop print_sorted_keys  ; Повторити для всіх ключів



print_word proc
    ; Переведення двобайтового слова у десятковий формат та вивід його
    ; AX - значення для виведення
    push ax                 ; Збереження значення AX
    mov cx, 10              ; Ділення на 10
    xor dx, dx              ; Очистка DX
    div cx                  ; AX = AX / 10 (результат у AL, залишок у AH)

    ; Рекурсивне виведення
    cmp ax, 0                ; Перевірка, чи досягнуто останнього розряду
    jz print_last_digit     ; Якщо так, виведення останнього розряду
    call print_word         ; Виведення наступного розряду

print_last_digit:
    ; Виведення останнього розряду
    pop ax                  ; Відновлення значення AX
    add dl, '0'             ; Конвертація у ASCII
    mov ah, 02h             ; DOS-функція для виводу символу
    int 21h                 ; DOS переривання
    ret
print_word endp

exit_program:
    ; Завершення програми
    mov ax, 4c00h
    int 21h

main endp
end main
